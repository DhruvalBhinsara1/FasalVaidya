{
  "meta": {
    "role": "Senior Machine Learning Engineer",
    "task_type": "Code Refactoring & Data Pipeline Optimization",
    "priority": "Critical",
    "target_file": "FasalVaidya_EfficientNetB0_Training.ipynb",
    "section_focus": "2. Dataset Loading and Balancing"
  },
  "context": {
    "issue_summary": "The current notebook discards valid training data because it enforces a hard floor of 150 images and a hard ceiling of 500 images. Our dataset is highly imbalanced, with some minority classes having as few as 60 images.",
    "business_impact": "Classes with <150 images are completely dropped, leading to model blindness for those specific nutrient deficiencies.",
    "required_change": "Switch from 'Fixed Threshold' balancing to 'Dynamic Target' balancing based on the dataset's median distribution."
  },
  "technical_specifications": {
    "algorithm_strategy": "Dynamic Median Balancing",
    "input_data": "A Pandas DataFrame (e.g., `df`) containing at least columns: ['filepath', 'label']",
    "random_seed": 42
  },
  "implementation_steps": [
    {
      "step": 1,
      "action": "Analyze Distribution",
      "details": "Compute the value counts of the 'label' column. Store the counts in a variable (e.g., `class_counts`)."
    },
    {
      "step": 2,
      "action": "Calculate Dynamic Target",
      "details": "Compute the median of `class_counts` to serve as the 'TARGET_SIZE'. This ensures the target is representative of the actual data, not an arbitrary number. \nFormula: `TARGET_SIZE = int(class_counts.median())`."
    },
    {
      "step": 3,
      "action": "Refactor Balancing Loop",
      "instruction": "Iterate through each unique class label and apply the following logic:",
      "logic_block": {
        "case_minority": "IF class_count < TARGET_SIZE: Sample `TARGET_SIZE` samples from this class with replacement (`replace=True`). This duplicates images to fill the gap.",
        "case_majority": "IF class_count > TARGET_SIZE: Sample `TARGET_SIZE` samples from this class without replacement (`replace=False`). This trims the excess.",
        "case_exact": "IF class_count == TARGET_SIZE: Keep as is."
      }
    },
    {
      "step": 4,
      "action": "DataFrame Reconstruction",
      "details": "Concatenate all balanced class subsets into a new DataFrame `balanced_df`. Shuffle this final DataFrame to prevent ordering bias during training."
    }
  ],
  "verification_requirements": [
    {
      "check": "No Data Loss",
      "expectation": "Verify that `balanced_df['label'].nunique()` matches the original number of classes (43 expected)."
    },
    {
      "check": "Uniform Distribution",
      "expectation": "Print `balanced_df['label'].value_counts()`. All classes must show the exact same count (equal to TARGET_SIZE)."
    },
    {
      "check": "Visual Confirmation",
      "expectation": "Plot a bar chart of the new distribution to confirm a perfectly flat line across all classes."
    }
  ],
  "code_snippets_reference": {
    "upsampling_syntax": "df_class.sample(n=TARGET_SIZE, replace=True, random_state=42)",
    "downsampling_syntax": "df_class.sample(n=TARGET_SIZE, replace=False, random_state=42)"
  }
}
